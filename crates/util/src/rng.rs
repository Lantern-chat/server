use std::cell::UnsafeCell;
use std::rc::Rc;

use rand::rngs::{adapter::ReseedingRng, OsRng};
use rand::{RngCore, SeedableRng};
use rand_chacha::ChaCha20Core;

#[derive(Clone, Debug)]
pub struct CryptoThreadRng {
    rng: Rc<UnsafeCell<ReseedingRng<ChaCha20Core, OsRng>>>,
}

// Number of generated bytes after which to reseed `CryptoThreadRng`.
// According to benchmarks, reseeding has a noticable impact with thresholds
// of 32 kB and less. We choose 128 kB to avoid significant overhead.
const THREAD_RNG_RESEED_THRESHOLD: u64 = 1024 * 128;

thread_local!(
    // We require Rc<..> to avoid premature freeing when thread_rng is used
    // within thread-local destructors. See #968.
    static CRYPTO_THREAD_RNG_KEY: Rc<UnsafeCell<ReseedingRng<ChaCha20Core, OsRng>>> = {
        let r = ChaCha20Core::from_rng(OsRng).unwrap_or_else(|err| panic!("could not initialize thread_rng: {err}"));
        let rng = ReseedingRng::new(r, THREAD_RNG_RESEED_THRESHOLD, OsRng);
        Rc::new(UnsafeCell::new(rng))
    }
);

pub fn crypto_thread_rng() -> CryptoThreadRng {
    let rng = CRYPTO_THREAD_RNG_KEY.with(|t| t.clone());
    CryptoThreadRng { rng }
}

impl Default for CryptoThreadRng {
    fn default() -> CryptoThreadRng {
        crate::rng::crypto_thread_rng()
    }
}

impl CryptoThreadRng {
    #[inline(always)]
    fn rng(&mut self) -> &mut ReseedingRng<ChaCha20Core, OsRng> {
        // SAFETY: We must make sure to stop using `rng` before anyone else
        // creates another mutable reference
        unsafe { &mut *self.rng.get() }
    }

    pub fn gen_bytes<const N: usize>(&mut self) -> [u8; N] {
        let mut bytes = [0; N];
        self.rng().fill_bytes(&mut bytes);
        bytes
    }
}

impl RngCore for CryptoThreadRng {
    #[inline(always)]
    fn next_u32(&mut self) -> u32 {
        self.rng().next_u32()
    }

    #[inline(always)]
    fn next_u64(&mut self) -> u64 {
        self.rng().next_u64()
    }

    #[inline(always)]
    fn fill_bytes(&mut self, dest: &mut [u8]) {
        self.rng().fill_bytes(dest)
    }

    #[inline(always)]
    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), rand::Error> {
        self.rng().try_fill_bytes(dest)
    }
}

impl rand::CryptoRng for CryptoThreadRng {}
