/// Print Schema
#[derive(argh::FromArgs)]
pub struct Arguments {
    /// database connection string for PostgreSQL
    #[argh(option, short = 'd')]
    db: String,

    /// where to store generated schema file
    #[argh(option, short = 'o')]
    out: Option<std::path::PathBuf>,

    /// specific database schema to use
    #[argh(option, short = 's')]
    schema: Option<String>,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let args: Arguments = argh::from_env();

    use db::{Object, Pool};

    let pool = Pool::new(args.db.parse()?, db::pg::NoTls);
    let db = Object::take(pool.get().await?);

    let schema = thorn::generate::generate(db.as_ref(), args.schema.clone()).await?;

    if let Some(out) = args.out {
        use std::io::Write;

        let mut file = std::fs::OpenOptions::new().truncate(true).write(true).open(out)?;

        match args.schema {
            Some(schema) => write!(file, "//! Autogenerated Schema for \"{schema}\"\n\n")?,
            None => write!(file, "//! Autogenerated Schema")?,
        }

        file.write_all(schema.as_bytes())?;
    } else {
        println!("{schema}");
    }

    Ok(())
}
